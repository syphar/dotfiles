use_nvm_from_nvm_rc() {
  if [[ ! -f .nvmrc ]]; then
    log_error 'No .nvmrc found'
    exit 2
  fi

  local version=$(cat .nvmrc)
  use_nvm "$version"
}

use_nvm() {
  local node_version=$1
  nvm_sh=$(brew --prefix)/opt/nvm/nvm.sh

  which nvm || source $nvm_sh
  # if [[ -e $nvm_sh ]]; then
  #   source $nvm_sh
  nvm use $node_version
  # fi
}

layout_uv() {
  local python_version=${1:-}
  local venv_dir=".venv"
  local python_bin="$venv_dir/bin/python"

  # already activated?
  if [[ "${VIRTUAL_ENV:-""}" == "$PWD/$venv_dir" && -x "$python_bin" ]]; then
    return 0
  fi

  export VIRTUAL_ENV="$PWD/$venv_dir"

  if [[ -x "$python_bin" ]]; then
    layout python "$python_bin"
    return 0
  fi

  if [[ ! -f pyproject.toml && \
      ! -f .python-version && \
      -z "$python_version" ]]; then
    return 0
  fi

  echo "direnv: creating virtualenv via uv in $venv_dir"
  mkdir -p "$venv_dir"

  echo $1
  local python_version_arg=""
  if [[ -n "${python_version}" ]]; then
    local python_version_arg="--python $python_version"
  fi

  # NOTE: uv can natively read the required python version from 
  # `.python-version` or `pyproject.toml`.
  # it also supports version ranges.
  uv venv --clear "$venv_dir" $python_version_arg

  if [[ -x "$python_bin" ]]; then
    layout python "$python_bin"
  fi

  export UV_ACTIVE=1
  export UV_PROJECT_ENVIRONMENT=$VIRTUAL_ENV
}

# vim: et ts=2 sts=2 sw=2
